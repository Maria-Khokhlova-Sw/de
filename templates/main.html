<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <title>Логин с капчей</title>
    <link rel="stylesheet" href="./static/css/style.css" />

</head>
<body>
<h2>Логин</h2>

<input type="text" id="login" class="login" placeholder="Login" />
<input type="password" id="password" class="password" placeholder="Password" />
<button class="loginBtn" disabled>Login</button>

<p class="message"></p>

<div class="captcha">
    <h3>Капча — соберите фрагменты в порядке 1 → 2 → 3 → 4</h3>
    <div class="selection" aria-label="Выбранные фрагменты"></div>
    <div class="pool" aria-label="Фрагменты для выбора"></div>
    <div style="margin-top:8px;">
        <button class="clearCaptcha">Очистить капчу</button>
        <button class="reshuffle">Перемешать</button>
    </div>
</div>

<script>
    const pool         = document.querySelector('.pool');
    const selection    = document.querySelector('.selection');
    const loginInput   = document.querySelector('.login');
    const passInput    = document.querySelector('.password');
    const loginBtn     = document.querySelector('.loginBtn');
    const msg          = document.querySelector('.message');
    const clearBtn     = document.querySelector('.clearCaptcha');
    const reshuffleBtn = document.querySelector('.reshuffle');
    const IMAGES = [1, 2, 3, 4];


    const getOrder = () =>
        Array.from(selection.children, el => Number(el.dataset.index));
    //берем все дочерние элементы из selection и записываем их dataset.index в getOrder в выбранном пользователем порядке

    function updateUI() {
        loginBtn.disabled = getOrder().length !== IMAGES.length;
    }

    function shuffle(arr) {
        return arr.slice().sort(() => Math.random() - 0.5);
    }

    function makeImg(index) {
        const img = document.createElement('img');
        img.src = `template/${index}.png`;
        img.alt = `фрагмент ${index}`;
        img.dataset.index = index;
        img.className = 'piece';
        return img;
    }

    function renderPool() {
        selection.replaceChildren();
        const nodes = shuffle(IMAGES).map(makeImg);
        pool.replaceChildren(...nodes);
        updateUI();
    }


    function clearSelection() {
        while (selection.firstChild)
            pool.appendChild(selection.firstChild);
        updateUI();
    }

    pool.addEventListener('click', (e) => {
        const img = e.target.closest('img');
        if (!img || !pool.contains(img)) return;
        if (selection.children.length >= IMAGES.length) return;
        selection.appendChild(img);
        img.classList.add('selected');
        updateUI();
    });

    selection.addEventListener('click', (e) => {
        const img = e.target.closest('img');
        if (!img || !selection.contains(img)) return;
        img.classList.remove('selected');
        pool.appendChild(img);
        updateUI();
    });

    clearBtn.addEventListener('click', (e) => {
        e.preventDefault();
        clearSelection();
    });

    reshuffleBtn.addEventListener('click', (e) => {
        e.preventDefault();
        renderPool();
    });

    loginBtn.addEventListener('click', async () => {
        if (!loginInput) {
            msg.innerText = 'Введите логин';
            return;
        }
        if (!passInput) {
            msg.innerText = 'Введите пароль';
            return;
        }

        loginBtn.disabled = true;
        try {
            const response = await fetch('/login', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    loginInput,
                    passInput,
                    captcha_order: getOrder
                })
            });
            const data = await response.json();
            msg.innerText = data.message || JSON.stringify(data);

            if (data.status === 'success') {
                loginBtn.disabled = true;
            } else {
                clearSelection();
                renderPool();
            }
        } catch (err) {
            msg.innerText = 'Ошибка связи с сервером';
        } finally {
            updateUI();
        }
    });

    renderPool();
</script>
</body>
</html>
